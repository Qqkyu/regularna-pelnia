4 typy języków generowanych przez wyrażenia regularne: 
  wyrażenia postaci "e" - (0) tylko epsilon - {e}
  wyrażenia postaci "aa*" - (M[n]) podzbiór języka pełnego bez 0,1,..,n, np. dla M[2] {aaa,aaaa,..}
  wyrażenia postaci "aaa" - (P[n1,n2,..]) podzbiór języka pełnego zawierający n1,n2,.., np. dla [1,2] {a,aa}
  wyrażenia postaci "a*" - (X) a*

1)
Dane:
  Brak
Działanie:
  Czy w wyrażeniu regularnym jest gdziekolwiek a*?
  - Nie:
    - wyrażenie regularne nie generuje języka pełnego
  - Tak:
    - w wyrażeniu regularnym znajduje się a*

2) 
Dane:
  - wyrażenie regularne
  - w wyrażeniu regularnym znajduje się a*
Działanie:
  Pozbycie się nawiasów poprzez przekształcenie wyrażenia regularnego na mniejsze części, np. "a+(a+e)(a*e)+a*e" -> ["a+","a+e","a*e","+a*e"]

3)
Dane:
  - wyrażenie regularne pogrupowane na części odpowiadające nawiasom
  - w wyrażeniu regularnym znajduje się a*
Działanie:
  Zmapowanie każdej "części" na odpowiedni typ języka, który generuje, np. "aa*+e+a*+aaa" + a mapuje się do "M[0]+0+X+P[3]"

4)
Dane:
  - wyrażenie regularne pogrupowane na części
  - każda podczęść zamieniona na język który generuje: 0, M[n], P[n], X
  - w wyrażeniu regularnym znajduje się a*
Działanie:
  Przypisanie każdej części języka który generuje
  - przejście przez wszystkie części i sprawdzenie, jakie języki one generują 
  - przypisanie typu języka do każdego z nawiasów pozwala stwierdzić, czy wyrażenie regularne generuje język pełny
  - łączenie nawiasów:
    - alternatywa - rekurencyjnie sprawdzamy czy którakolwiek ze stron generuje język pełny
    - konkatenacja:
      (0) i (0) - (0)
      (0) i (M[n]) - M[n]
      (0) i (P[n]) - if n == 0 then P[n] else P[0,n]
      (0) i (X) - (X)
      (M[n) i (M[m]) - (M[n+m+1])
      (M[n]) i (P[m]) - (M[n+m])
      (M[n]) i (X) - (M[n])
      (P[n]) i (P[m]) - (P[n+m])
      (P[n]) i (X) - (M[n-1])
      (X) i (X) - (X)

