4 typy języków generowanych przez wyrażenia regularne: 
  wyrażenia postaci "e" - (0) tylko epsilon - {e}
  wyrażenia postaci "aa*" - (M[n]) podzbiór języka pełnego bez 0,1,..,n, np. dla M[2] {aaa,aaaa,..}
  wyrażenia postaci "aaa" - (P[n1,n2,..]) podzbiór języka pełnego zawierający n1,n2,.., np. dla [1,2] {a,aa}
  wyrażenia postaci "a*" - (X) a*
  wyrażenia skonkatenowane: (N[n1..m1,n2..m2,..]) - podzbiór języka pełnego bez n1-m1,n2-m2,..

1)
Dane:
  Brak
Działanie:
  Czy w wyrażeniu regularnym jest gdziekolwiek a*?
  - Nie:
    - wyrażenie regularne nie generuje języka pełnego
  - Tak:
    - w wyrażeniu regularnym znajduje się a*

2) 
Dane:
  - wyrażenie regularne
  - w wyrażeniu regularnym znajduje się a*
Działanie:
  Pozbycie się nawiasów poprzez przekształcenie wyrażenia regularnego na mniejsze części, np. "a+(a+e)(a*e)+a*e" -> ["a","+","a+e","a*e","+","a*e"]

3)
Dane:
  - wyrażenie regularne pogrupowane na części odpowiadające nawiasom
  - w wyrażeniu regularnym znajduje się a*
Działanie:
  Zmapowanie każdej "części" na odpowiedni typ języka, który generuje, np. "aa*+e+a*+aaa" + a mapuje się do "M[0]+0+X+P[3]"

4)
Dane:
  - wyrażenie regularne pogrupowane na części
  - każda podczęść zamieniona na język który generuje: 0, M[n], P[n], X
  - w wyrażeniu regularnym znajduje się a*
  - przykładowe wejście: ["P[1]","+","P[1]+0","X","+","X"]
Działanie:
  Przypisanie każdej części języka który generuje
  - przejście przez wszystkie części i sprawdzenie, jakie języki one generują 
  - przypisanie typu języka do każdego z nawiasów pozwala stwierdzić, czy wyrażenie regularne generuje język pełny
  - alternatywa:
    (0) i (0) - (0)
    (0) i (M[n]) - if n == 0 then X else N[1..n]
    (0) i (P[n]) - P[0,n]
    (0) i (X) - (X)
    (M[n]) i (M[m]) - if n < m then M[n] else M[m]
    (M[n]) i (P[m]) - if n <= m then M[m-n] else N[0..m-1,m+1..n]
    (M[n]) i (X) - (X)
    (P[n]) i (P[m]) - (P[n,m])
    (P[n]) i (X) - (X)
    (X) i (X) - (X)

5)
  - łączenie nawiasów:
    - alternatywa - rekurencyjnie sprawdzamy czy którakolwiek ze stron generuje język pełny
    - konkatenacja:
      (0) i (0) - (0)
      (0) i (M[n]) - M[n]
      (0) i (P[n]) - P[0,n]
      (0) i (X) - (X)
      (M[n) i (M[m]) - (M[n+m+1])
      (M[n]) i (P[m]) - (M[n+m])
      (M[n]) i (X) - (M[n])
      (P[n]) i (P[m]) - (P[n+m])
      (P[n]) i (X) - (M[n-1])
      (X) i (X) - (X)
